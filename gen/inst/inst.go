package main

import (
	"fmt"
	"go/format"
	"os"
	"sort"
	"strings"

	"github.com/wdamron/arm"
	"github.com/wdamron/arm/gen/inst/instref"
	"github.com/wdamron/arm/gen/inst/opmap"
)

func main() {
	names := make([]string, 0, len(opmap.EncMap))
	for name := range opmap.EncMap {
		names = append(names, name)
	}
	sort.Strings(names)

	const docLineChars = 96 // pad
	encDocMap := instref.Get(docLineChars)
	encDescMap, err := instref.Descriptions()
	if err != nil {
		panic(err.Error())
	}

	var encOffset uint32
	var out *strings.Builder

	// ------------------------ encoding commands ------------------------

	out = new(strings.Builder)
	out.Grow(128 * 1024)
	encOffset = 0
	cmdOffsets := make([]uint32, 0, len(names)*3)
	out.WriteString("// Code generated by gen/inst/inst.go; DO NOT EDIT.\n\n")
	out.WriteString("package arm\n\n")

	out.WriteString("// The Commands table contains opcode/encoding info for all instructions.\n")
	out.WriteString("// Each encoding contains a 32-bit opcode, followed by a length-prefixed list\n")
	out.WriteString("// of encoding operators. Encoding operators apply to Flat types.\n")
	out.WriteString("// Opcode bytes are big-endian ordered to match encoding diagrams.\n")
	out.WriteString("// The table is indexed through offsets stored in the Patterns table.\n")
	out.WriteString("var Commands = [...]byte{\n")
	for _, name := range names {
		encs := opmap.EncMap[name]
		encDocList := encDocMap[name]
		for instEncIdx, enc := range encs {
			for _, width := range encDocList[instEncIdx] { // 1/2 register widths
				out.WriteString("\t// ")
				out.WriteString(width.Doc)
				out.WriteByte('\n')
				if width.Size == 0 { // single width
					break
				}
			}

			encStart := encOffset
			cmdOffsets = append(cmdOffsets, encStart)
			// Formatted big-endian to match encoding diagrams:
			fmt.Fprintf(out, "\t0b%08b, 0b%08b, 0b%08b, 0b%08b,", byte(enc.Op>>24), byte(enc.Op>>16), byte(enc.Op>>8), byte(enc.Op))
			encOffset += 4
			fmt.Fprintf(out, " %d,", len(enc.Cmds))
			encOffset++
			for _, c := range enc.Cmds {
				fmt.Fprintf(out, " %s,", arm.CmdName[c.Op])
				encOffset++
				for i, x := range c.X[:arm.CmdArgCounts[c.Op]] {
					switch c.Op {
					case arm.CmdOffset:
						fmt.Fprintf(out, " %s,", arm.CmdName[x])
					case arm.CmdSpecial:
						if i == 1 {
							fmt.Fprintf(out, " %s,", arm.SpecialName[x])
						} else {
							fmt.Fprintf(out, " %d,", x)
						}
					case arm.CmdLitList:
						if i == 1 {
							fmt.Fprintf(out, " %s,", arm.CmdName[x])
						} else {
							fmt.Fprintf(out, " %d,", x)
						}
					default:
						fmt.Fprintf(out, " %d,", x)
					}
					encOffset++
				}
			}
			out.WriteByte('\n')
		}

		out.WriteByte('\n')
	}
	out.WriteString("}\n")

	formatted, err := format.Source([]byte(out.String()))
	if err != nil {
		panic(err.Error())
	}
	if err := os.WriteFile("inst_commands.go", formatted, 0664); err != nil {
		panic(err.Error())
	}

	// ------------------------ encoding patterns ------------------------

	out = new(strings.Builder)
	out.Grow(128 * 1024)
	encOffset = 1
	var encIdx int
	patternOffsets := make([]uint32, len(names))
	out.WriteString("// Code generated by gen/inst/inst.go; DO NOT EDIT.\n\n")
	out.WriteString("package arm\n\n")

	out.WriteString("// The Patterns table contains matching info for all instruction encodings.\n")
	out.WriteString("// Each instruction's list of encodings is prefixed with the encoding count,\n")
	out.WriteString("// followed by a length-prefixed list of matching operators and commands offset\n")
	out.WriteString("// for each encoding; the commands offset is a 16-bit index into the Commands table.\n")
	out.WriteString("// Matching operators apply to unflattened Arg types.\n")
	out.WriteString("var Patterns = [...]byte{\n\t0,\n")
	for i, name := range names {
		patternOffsets[i] = encOffset
		encs := opmap.EncMap[name]
		fmt.Fprintf(out, "\t%d,\n", len(encs))
		encOffset++
		encDocList := encDocMap[name]
		for instEncIdx, enc := range encs {
			for _, width := range encDocList[instEncIdx] { // 1/2 register widths
				out.WriteString("\t// ")
				out.WriteString(width.Doc)
				out.WriteByte('\n')
				if width.Size == 0 { // single width
					break
				}
			}
			fmt.Fprintf(out, "\t%d,", len(enc.Match))
			encOffset++
			for _, m := range enc.Match {
				fmt.Fprintf(out, " %s,", arm.MatchName[m.Op])
				encOffset++
				for i, x := range m.X[:arm.MatcherArgCounts[m.Op]] {
					switch m.Op {
					case arm.MatLitSymbol:
						fmt.Fprintf(out, " byte(%s),", arm.SymbolName[x])
					case arm.MatMod:
						fmt.Fprintf(out, " %s,", arm.ModListName[x])
					case arm.MatLitMod:
						fmt.Fprintf(out, " %s,", arm.ModName[x])
					case arm.MatV, arm.MatVStatic, arm.MatVElement, arm.MatVElementStatic, arm.MatVStaticElement:
						if i == 0 {
							fmt.Fprintf(out, " byte(%s),", arm.SizeName[x])
						} else {
							fmt.Fprintf(out, " %d,", x)
						}
					case arm.MatRegList, arm.MatRegListStatic, arm.MatRegListElement:
						if i == 1 {
							fmt.Fprintf(out, " byte(%s),", arm.SizeName[x])
						} else {
							fmt.Fprintf(out, " %d,", x)
						}
					default:
						fmt.Fprintf(out, " %d,", x)
					}
					encOffset++
				}
			}
			cmd := cmdOffsets[encIdx]
			fmt.Fprintf(out, " 0x%x, 0x%x,\n", uint8(cmd>>8), uint8(cmd))
			encOffset += 2
			encIdx++
		}

		out.WriteByte('\n')
	}
	out.WriteString("}\n")

	formatted, err = format.Source([]byte(out.String()))
	if err != nil {
		panic(err.Error())
	}
	if err := os.WriteFile("inst_patterns.go", formatted, 0664); err != nil {
		panic(err.Error())
	}

	// ------------------------ mnemonics ------------------------

	out = new(strings.Builder)
	out.Grow(128 * 1024)
	out.WriteString("// Code generated by gen/inst/inst.go; DO NOT EDIT.\n")
	out.WriteString("//go:generate go run gen/inst/inst.go\n\n")

	out.WriteString("package arm\n\n")

	out.WriteString("// Inst is an instruction mnemonic. The integer value is an offset into the Patterns array.\n")
	out.WriteString("type Inst uint16\n\n")

	out.WriteString("// Instructions\n")
	out.WriteString("const (\n")
	for i, name := range names {
		fmt.Fprintf(out, "\t%s Inst = %d\n", strings.ToUpper(name), patternOffsets[i])
	}
	out.WriteString(")\n")

	formatted, err = format.Source([]byte(out.String()))
	if err != nil {
		panic(err.Error())
	}
	if err := os.WriteFile("inst.go", formatted, 0664); err != nil {
		panic(err.Error())
	}

	// ------------------------ instruction docs ------------------------

	out = new(strings.Builder)
	out.Grow(256 * 1024)

	out.WriteString("# Instruction Reference\n")
	out.WriteString("<!-- Markdown generated by gen/inst/inst.go; DO NOT EDIT. -->\n\n")

	out.WriteString("The following list includes all supported instructions in alphabetical order, with a list of possible\n")
	out.WriteString("encodings for each instruction.\n\n")

	out.WriteString("Instructions encodings may include constraints indicating allowed register numbers, immediate ranges,\n")
	out.WriteString("and immediate alignment. Where a constraint indicates a right shift, the immediate value is shifted\n")
	out.WriteString("during encoding but the provided argument should not be shifted beforehand; the shift amount indicates\n")
	out.WriteString("the required alignment for the provided argument.\n\n\n")

	writeAliasLinks := func(nameDesc instref.NameDesc) {
		if len(nameDesc.AliasOf) != 0 {
			out.WriteString(instref.AliasPrefix)
			sep := ""
			for _, other := range nameDesc.AliasOf {
				fmt.Fprintf(out, "%s[%s](#%s)", sep, other.Name, strings.ToLower(other.Mnemonic))
				sep = ", "
			}
			out.WriteByte('.')
		}
	}

	for _, name := range names {
		fmt.Fprintf(out, "## %s\n\n", strings.ToUpper(name))

		if descs := encDescMap[strings.ToUpper(name)]; len(descs) == 0 {
			panic("No descriptions for " + name)
		} else if len(descs) == 1 {
			nameDesc := descs[0]
			out.WriteString(nameDesc.Desc)
			writeAliasLinks(nameDesc)
			out.WriteString("\n\n")
		} else if len(descs) == 0 {
			panic("no descs for " + name)
		} else {
			for _, nameDesc := range descs {
				fmt.Fprintf(out, "- _%s_: %s", nameDesc.Name, nameDesc.Desc)
				writeAliasLinks(nameDesc)
				out.WriteByte('\n')
			}
			out.WriteByte('\n')
		}

		out.WriteString("```\n")
		for _, encWidths := range encDocMap[name] {
			for _, width := range encWidths {
				out.WriteString(width.Doc)
				out.WriteByte('\n')
				if width.Size == 0 { // single width
					break
				}
			}
		}
		out.WriteString("```\n\n")
	}

	if err := os.WriteFile("INSTRUCTIONS.md", []byte(out.String()), 0664); err != nil {
		panic(err.Error())
	}
}
